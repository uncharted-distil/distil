<!--

    Copyright Â© 2021 Uncharted Software Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->

<template>
  <b-modal
    id="settings"
    title="Model Creation Settings"
    @ok="handleOk"
    @show="onShow"
  >
    <b-form-group
      id="model-limit"
      label="Maximum Generated Models:"
      label-for="num-models-spinner"
      description="Limits the number of models generated by the search process."
    >
      <b-form-spinbutton
        id="model-limit-spinner"
        v-model="modelLimit"
        inline
        min="1"
        max="100"
      />
    </b-form-group>
    <b-form-group
      id="time-limit"
      label="Time Limit:"
      label-for="time-limit-spinner"
      description="Sets that maximum allowed model search time in minutes."
    >
      <b-form-spinbutton
        id="time-limit-spinner"
        v-model="timeLimit"
        inline
        min="1"
        max="240"
      />
    </b-form-group>

    <b-form-checkbox
      v-if="hasTimeRange"
      v-model="splitByTime"
      class="float-right"
      size="sm"
      switch
    >
      Split dataset by time
    </b-form-checkbox>
    <b-form-group
      label="Training/Testing Data Split:"
      label-for="model-train-test-split"
      description="Modify the ratio of data used to train the model vs. the amount of data saved to verify the model for later."
    >
      <b-form-datepicker
        v-if="splitByTime"
        v-model="timestampSplitValue"
        :min="new Date(secondsToMillis(timeRange.min))"
        :max="new Date(secondsToMillis(timeRange.max))"
        locale="en"
        value-as-date
      />
      <template v-else>
        <div class="d-flex justify-content-between mt-1">
          <div>Training: {{ trainingCount }}</div>
          <div>Testing: {{ testingCount }}</div>
        </div>
        <b-form-input
          v-model="trainingCount"
          type="range"
          min="1"
          :max="totalDataCount"
          class="mt-1"
        />
        <div class="d-flex justify-content-between mt-1">
          <div>{{ parseFloat(trainingRatio).toFixed(2) }}%</div>
          <div>{{ parseFloat(testingRatio).toFixed(2) }}%</div>
        </div>
      </template>
    </b-form-group>
    <b-form-group
      label="Model Training:"
      label-for="model-training-ratios"
      description="Selects faster model training or higher quality models."
    >
      <b-form-radio
        v-model="speedQuality"
        name="model-training-radios"
        value="speed"
      >
        Faster
      </b-form-radio>
      <b-form-radio
        v-model="speedQuality"
        name="model-training-radios"
        value="quality"
      >
        Higher Quality
      </b-form-radio>
    </b-form-group>
    <b-form-group
      label="Model Scoring:"
      label-for="model-scoring"
      description="Selects model accuracy scoring method."
    >
      <b-form-select v-model="selectedMetric" name="model-scoring" size="sm">
        <b-form-select-option
          v-for="metric in metrics"
          :key="metric.value.id"
          :value="metric.value.id"
        >
          {{ metric.text }}
        </b-form-select-option>
      </b-form-select>
      <p>
        <small>
          {{ description }}
        </small>
      </p>
    </b-form-group>
    <b-form-group
      v-if="multipleTasks"
      label="Model Task:"
      label-for="model-task"
      description="Selects model task."
    >
      <b-form-select v-model="selectedTask" name="model-task" size="sm">
        <b-form-select-option v-for="task in tasks" :key="task" :value="task">
          {{ task }}
        </b-form-select-option>
      </b-form-select>
    </b-form-group>
  </b-modal>
</template>

<script lang="ts">
import Vue from "vue";
import { ModelQuality } from "../store/requests";
import {
  getters as datasetGetters,
  actions as datasetActions,
} from "../store/dataset/module";
import { overlayRouteEntry } from "../util/routes";
import { MetricDropdownItem, TaskTypes } from "../store/dataset";
import { getters as routeGetters } from "../store/route/module";
import { getters as appGetters } from "../store/app/module";

/**
 * Dialog for setting model creation preferences.
 * The results are saved to the route to ensure that users don't have to
 * set them for each run.
 */
export default Vue.extend({
  name: "SettingsModal",

  props: {
    timeRange: {
      type: Object as () => { min: number; max: number },
      default: null,
    },
  },

  data() {
    return {
      modelLimit: routeGetters.getModelLimit(this.$store) || 5,
      timeLimit: routeGetters.getModelTimeLimit(this.$store) || 5,
      speedQuality:
        routeGetters.getModelQuality(this.$store) ||
        ModelQuality.HIGHER_QUALITY,
      // fill this from the API later, first posting back the target's type
      // then getting a list of allowed scoring methods with keys, description
      selectedMetric: null,
      selectedTask: null,
      trainingCount: 1,
      timestampSplitValue: new Date(),
      splitByTime: false,
    };
  },

  computed: {
    description(): string {
      return this.metrics.filter((m) => m.value.id === this.selectedMetric)[0]
        ?.value?.description;
    },

    metrics(): MetricDropdownItem[] {
      const baseMetrics = datasetGetters.getModelingMetrics(this.$store);
      return baseMetrics.map((m) => {
        return {
          value: {
            id: m.id,
            description: m.description,
          },
          text: m.displayName,
        };
      });
    },

    multipleTasks(): boolean {
      // hack to only really be true when classification and segmentation is possible
      return (
        this.task.includes(TaskTypes.REMOTE_SENSING) && this.tasks.length > 1
      );
    },

    tasks(): string[] {
      // hack to only really be allow for classification and segmentation
      return this.task
        .split(",")
        .filter((t) => t != TaskTypes.REMOTE_SENSING && t != TaskTypes.BINARY);
    },

    task(): string {
      return routeGetters.getRouteTask(this.$store) ?? "";
    },

    rebuildTask(): string {
      // hack to submit only either classification or segmentation when dealing with remote sensing
      if (this.multipleTasks) {
        // if no task selected, then return null
        if (this.selectedTask) {
          return (
            TaskTypes.REMOTE_SENSING +
            "," +
            TaskTypes.BINARY +
            "," +
            this.selectedTask
          );
        }
        return null;
      }

      return this.task;
    },

    totalDataCount(): number {
      return datasetGetters.getIncludedTableDataNumRows(this.$store);
    },

    trainTestSplit(): number {
      return appGetters.getTrainTestSplit(this.$store);
    },

    trainTestSplitTimeSeries(): number {
      return appGetters.getTrainTestSplitTimeSeries(this.$store);
    },

    testingCount(): number {
      return this.totalDataCount - this.trainingCount;
    },

    testingRatio(): number {
      return 1 - this.trainingRatio;
    },

    trainingRatio(): number {
      return this.trainingCount / this.totalDataCount;
    },

    hasTimeRange(): boolean {
      return this.timeRange !== null;
    },

    baseSplit(): number {
      const routeSplit = routeGetters.getRouteTrainTestSplit(this.$store);
      return !!routeSplit
        ? routeSplit
        : this.task.includes(TaskTypes.TIME_SERIES)
        ? this.trainTestSplit
        : this.trainTestSplitTimeSeries;
    },
  },

  watch: {
    baseSplit() {
      this.trainingCount =
        Math.floor(this.totalDataCount * this.baseSplit) || 1;
    },

    totalDataCount() {
      this.trainingCount =
        Math.floor(this.totalDataCount * this.baseSplit) || 1;
    },

    timeRange() {
      if (!this.timeRange) return;
      const half = Math.floor((this.timeRange.max - this.timeRange.max) / 2);
      this.timestampSplitValue = new Date(
        this.secondsToMillis(this.timeRange.min + half)
      );
    },
  },

  async beforeMount() {
    const task = routeGetters.getRouteTask(this.$store);
    if (!task) return;

    await datasetActions.fetchModelingMetrics(this.$store, {
      task: this.task,
    });
    if (this.task.includes(TaskTypes.CLASSIFICATION)) {
      if (this.task.includes(TaskTypes.MULTICLASS)) {
        this.selectedMetric = "f1Macro";
      } else {
        this.selectedMetric = "f1";
      }
    } else if (this.task.includes(TaskTypes.REGRESSION)) {
      this.selectedMetric = "meanAbsoluteError";
    } else {
      this.selectedMetric = null;
    }
    this.trainingCount = Math.floor(this.totalDataCount * this.baseSplit) || 1;
  },

  methods: {
    onShow() {
      const routeMetric = routeGetters.getModelMetrics(this.$store);
      if (routeMetric) {
        this.selectedMetric = routeMetric[0];
        return;
      }
      if (this.task.includes(TaskTypes.CLASSIFICATION)) {
        if (this.task.includes(TaskTypes.MULTICLASS)) {
          this.selectedMetric = "f1Macro";
        } else {
          this.selectedMetric = "f1";
        }
      } else if (this.task.includes(TaskTypes.REGRESSION)) {
        this.selectedMetric = "meanAbsoluteError";
      } else {
        this.selectedMetric = null;
      }
      this.trainingCount =
        Math.floor(this.totalDataCount * this.baseSplit) || 1;
    },
    secondsToMillis(seconds: number): number {
      return seconds * 1000;
    },

    handleOk() {
      const entry = overlayRouteEntry(routeGetters.getRoute(this.$store), {
        modelLimit: this.modelLimit,
        modelTimeLimit: this.timeLimit,
        modelQuality: this.speedQuality,
        metrics: this.selectedMetric,
        selectedTask: this.rebuildTask,
        trainTestSplit: this.trainingRatio,
        timestampSplit:
          this.hasTimeRange && this.splitByTime
            ? this.timestampSplitValue.getTime() / 1000
            : null,
      });
      this.$router.push(entry).catch((err) => console.warn(err));
    },
  },
});
</script>
