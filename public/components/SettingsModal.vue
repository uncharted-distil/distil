<!--

    Copyright Â© 2021 Uncharted Software Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->

<template>
  <b-modal id="settings" title="Model Creation Settings" @ok="handleOk">
    <b-form-group
      id="model-limit"
      label="Maximum Generated Models:"
      label-for="num-models-spinner"
      description="Limits the number of models generated by the search process."
    >
      <b-form-spinbutton
        id="model-limit-spinner"
        v-model="modelLimit"
        inline
        min="1"
        max="100"
      />
    </b-form-group>
    <b-form-group
      id="time-limit"
      label="Time Limit:"
      label-for="time-limit-spinner"
      description="Sets that maximum allowed model search time in minutes."
    >
      <b-form-spinbutton
        id="time-limit-spinner"
        v-model="timeLimit"
        inline
        min="1"
        max="240"
      />
    </b-form-group>

    <b-form-checkbox
      v-if="hasTimeRange"
      v-model="splitByTime"
      class="float-right"
      size="sm"
      switch
    >
      Split dataset by time
    </b-form-checkbox>
    <b-form-group
      label="Training/Testing Data Split:"
      label-for="model-train-test-split"
      description="Modify the ratio of data used to train the model vs. the amount of data saved to verify the model for later."
    >
      <b-form-datepicker
        v-if="splitByTime"
        v-model="timestampSplitValue"
        :min="new Date(secondsToMillis(timeRange.min))"
        :max="new Date(secondsToMillis(timeRange.max))"
        locale="en"
        value-as-date
      />
      <template v-else>
        <div class="d-flex justify-content-between mt-1">
          <div>Training: {{ trainingCount }}</div>
          <div>Testing: {{ testingCount }}</div>
        </div>
        <b-form-input
          v-model="trainingCount"
          type="range"
          min="1"
          :max="totalDataCount"
          class="mt-1"
        />
        <div class="d-flex justify-content-between mt-1">
          <div>{{ parseFloat(trainingRatio).toFixed(2) }}%</div>
          <div>{{ parseFloat(testingRatio).toFixed(2) }}%</div>
        </div>
      </template>
    </b-form-group>
    <b-form-group
      label="Model Training:"
      label-for="model-training-ratios"
      description="Selects faster model training or higher quality models."
    >
      <b-form-radio
        v-model="speedQuality"
        name="model-training-radios"
        value="speed"
      >
        Faster
      </b-form-radio>
      <b-form-radio
        v-model="speedQuality"
        name="model-training-radios"
        value="quality"
      >
        Higher Quality
      </b-form-radio>
    </b-form-group>
    <b-form-group
      label="Model Scoring:"
      label-for="model-scoring"
      description="Selects model accuracy scoring method."
    >
      <b-form-select v-model="selectedMetric" name="model-scoring" size="sm">
        <b-form-select-option
          v-for="metric in metrics"
          :key="metric.value.id"
          :value="metric.value.id"
        >
          {{ metric.text }}
        </b-form-select-option>
      </b-form-select>
      <p>
        <small>
          {{ description }}
        </small>
      </p>
    </b-form-group>
  </b-modal>
</template>

<script lang="ts">
import Vue from "vue";
import { ModelQuality } from "../store/requests";
import {
  getters as datasetGetters,
  actions as datasetActions,
} from "../store/dataset/module";
import { overlayRouteEntry } from "../util/routes";
import { MetricDropdownItem, TaskTypes } from "../store/dataset";
import { getters as routeGetters } from "../store/route/module";
import { getters as appGetters } from "../store/app/module";

/**
 * Dialog for setting model creation preferences.
 * The results are saved to the route to ensure that users don't have to
 * set them for each run.
 */
export default Vue.extend({
  name: "SettingsModal",

  props: {
    timeRange: {
      type: Object as () => { min: number; max: number },
      default: null,
    },
  },

  data() {
    return {
      modelLimit: routeGetters.getModelLimit(this.$store) || 5,
      timeLimit: routeGetters.getModelTimeLimit(this.$store) || 5,
      speedQuality:
        routeGetters.getModelQuality(this.$store) ||
        ModelQuality.HIGHER_QUALITY,
      // fill this from the API later, first posting back the target's type
      // then getting a list of allowed scoring methods with keys, description
      selectedMetric: null,
      trainingCount: 1,
      timestampSplitValue: new Date(),
      splitByTime: false,
    };
  },

  computed: {
    description(): string {
      return this.metrics.filter((m) => m.value.id === this.selectedMetric)[0]
        ?.value?.description;
    },

    metrics(): MetricDropdownItem[] {
      const baseMetrics = datasetGetters.getModelingMetrics(this.$store);
      return baseMetrics.map((m) => {
        return {
          value: {
            id: m.id,
            description: m.description,
          },
          text: m.displayName,
        };
      });
    },

    task(): string {
      return routeGetters.getRouteTask(this.$store);
    },

    totalDataCount(): number {
      return routeGetters.getRouteDataSize(this.$store);
    },

    trainTestSplit(): number {
      return appGetters.getTrainTestSplit(this.$store);
    },

    trainTestSplitTimeSeries(): number {
      return appGetters.getTrainTestSplitTimeSeries(this.$store);
    },

    testingCount(): number {
      return this.totalDataCount - this.trainingCount;
    },

    testingRatio(): number {
      return 1 - this.trainingRatio;
    },

    trainingRatio(): number {
      return this.trainingCount / this.totalDataCount;
    },

    hasTimeRange(): boolean {
      return this.timeRange !== null;
    },

    baseSplit(): number {
      const routeSplit = routeGetters.getRouteTrainTestSplit(this.$store);
      return !!routeSplit
        ? routeSplit
        : this.task.includes(TaskTypes.TIME_SERIES)
        ? this.trainTestSplit
        : this.trainTestSplitTimeSeries;
    },

    routeTimestampSplit(): number {
      return routeGetters.getRouteTimestampSplit(this.$store);
    },
  },

  watch: {
    baseSplit() {
      this.trainingCount =
        Math.floor(this.totalDataCount * this.baseSplit) || 1;
    },

    totalDataCount() {
      this.trainingCount =
        Math.floor(this.totalDataCount * this.baseSplit) || 1;
    },

    timeRange() {
      if (!this.timeRange) return;
      const half = Math.floor((this.timeRange.max - this.timeRange.max) / 2);
      this.timestampSplitValue = new Date(
        this.secondsToMillis(this.timeRange.min + half)
      );
    },
  },

  async beforeMount() {
    const task = routeGetters.getRouteTask(this.$store);
    if (!task) return;

    await datasetActions.fetchModelingMetrics(this.$store, {
      task: this.task,
    });
    if (this.task.includes(TaskTypes.CLASSIFICATION)) {
      if (this.task.includes(TaskTypes.MULTICLASS)) {
        this.selectedMetric = "f1Macro";
      } else {
        this.selectedMetric = "f1";
      }
    } else if (this.task.includes(TaskTypes.REGRESSION)) {
      this.selectedMetric = "meanAbsoluteError";
    } else {
      this.selectedMetric = null;
    }
    this.trainingCount = Math.floor(this.totalDataCount * this.baseSplit) || 1;
  },

  methods: {
    secondsToMillis(seconds: number): number {
      return seconds * 1000;
    },

    handleOk() {
      const entry = overlayRouteEntry(routeGetters.getRoute(this.$store), {
        modelLimit: this.modelLimit,
        modelTimeLimit: this.timeLimit,
        modelQuality: this.speedQuality,
        metrics: this.selectedMetric,
        trainTestSplit: this.trainingRatio,
        timestampSplit:
          this.hasTimeRange && this.splitByTime
            ? this.timestampSplitValue.getTime() / 1000
            : null,
      });
      this.$router.push(entry).catch((err) => console.warn(err));
    },
  },
});
</script>
