<template>
  <b-modal
    id="settings"
    title="Model Creation Settings"
    @ok="handleOk"
    @hide="resetValues"
  >
    <template v-if="hasTimeRange && !hasSelectedSplitType">
      This dataset supports splitting by time. Would you like to split by time?
      <b-button variant="primary" @click="splitSettings(1)">Yes</b-button>
      <b-button variant="primary" @click="splitSettings(0)">No</b-button>
    </template>
    <div v-if="!hasTimeRange || hasSelectedSplitType">
      <b-form-group
        id="model-limit"
        label="Maximum Generated Models:"
        label-for="num-models-spinner"
        description="Limits the number of models generated by the search process."
      >
        <b-form-spinbutton
          id="model-limit-spinner"
          v-model="modelLimit"
          inline
          min="1"
          max="100"
        />
      </b-form-group>
      <b-form-group
        id="time-limit"
        label="Time Limit:"
        label-for="time-limit-spinner"
        description="Sets that maximum allowed model search time in minutes."
      >
        <b-form-spinbutton
          id="time-limit-spinner"
          v-model="timeLimit"
          inline
          min="1"
          max="240"
        />
      </b-form-group>
      <b-form-group
        label="Training/Testing Data Split:"
        label-for="model-train-test-split"
        description="Modify the ratio of data used to train the model vs. the amount of data saved to verify the model for later."
      >
        <b-form-datepicker
          v-if="shouldSplitByTime"
          v-model="timestampSplitValue"
          :min="new Date(secondsToMillis(timeRange.min))"
          :max="new Date(secondsToMillis(timeRange.max))"
          locale="en"
          value-as-date
        />
        <template v-else>
          <div class="d-flex justify-content-between mt-1">
            <div>Training: {{ trainingCount }}</div>
            <div>Testing: {{ testingCount }}</div>
          </div>
          <b-form-input
            v-model="trainingCount"
            type="range"
            min="1"
            :max="totalDataCount"
            class="mt-1"
          />
          <div class="d-flex justify-content-between mt-1">
            <div>{{ parseFloat(trainingRatio).toFixed(2) }}%</div>
            <div>{{ parseFloat(testingRatio).toFixed(2) }}%</div>
          </div>
        </template>
      </b-form-group>
      <b-form-group
        label="Model Training:"
        label-for="model-training-ratios"
        description="Selects faster model training or higher quality models."
      >
        <b-form-radio
          v-model="speedQuality"
          name="model-training-radios"
          value="speed"
        >
          Faster
        </b-form-radio>
        <b-form-radio
          v-model="speedQuality"
          name="model-training-radios"
          value="quality"
        >
          Higher Quality
        </b-form-radio>
      </b-form-group>
      <b-form-group
        label="Model Scoring:"
        label-for="model-scoring"
        description="Selects model accuracy scoring method."
      >
        <b-form-select v-model="selectedMetric" name="model-scoring" size="sm">
          <b-form-select-option
            v-for="metric in metrics"
            :key="metric.value.id"
            :value="metric.value.id"
          >
            {{ metric.text }}
          </b-form-select-option>
        </b-form-select>
        <p>
          <small>
            {{ description }}
          </small>
        </p>
      </b-form-group>
    </div>
  </b-modal>
</template>

<script lang="ts">
import Vue from "vue";
import { ModelQuality } from "../store/requests";
import {
  getters as datasetGetters,
  actions as datasetActions,
} from "../store/dataset/module";
import { overlayRouteEntry } from "../util/routes";
import { MetricDropdownItem, TaskTypes } from "../store/dataset";
import { getters as routeGetters } from "../store/route/module";
import { getters as appGetters } from "../store/app/module";
// Dialog for setting model creation preferences.  The results are saved to the route to ensure
// that users don't have to set them for each run.
export default Vue.extend({
  name: "settings-modal",
  props: {
    timeRange: {
      type: Object as () => { min: number; max: number },
      default: null,
    },
  },
  data() {
    return {
      modelLimit: routeGetters.getModelLimit(this.$store) || 5,
      timeLimit: routeGetters.getModelTimeLimit(this.$store) || 5,
      speedQuality:
        routeGetters.getModelQuality(this.$store) ||
        ModelQuality.HIGHER_QUALITY,
      // fill this from the API later, first posting back the target's type
      // then getting a list of allowed scoring methods with keys, description
      selectedMetric: null,
      trainingCount: 1,
      timestampSplitValue: new Date(),
      shouldSplitByTime: false,
      hasSelectedSplitType: false,
    };
  },

  computed: {
    description(): string {
      return this.metrics.filter((m) => m.value.id === this.selectedMetric)[0]
        ?.value?.description;
    },
    metrics(): MetricDropdownItem[] {
      const baseMetrics = datasetGetters.getModelingMetrics(this.$store);
      return baseMetrics.map((m) => {
        return {
          value: {
            id: m.id,
            description: m.description,
          },
          text: m.displayName,
        };
      });
    },
    task(): string {
      return routeGetters.getRouteTask(this.$store);
    },
    totalDataCount(): number {
      return routeGetters.getRouteDataSize(this.$store);
    },
    trainTestSplit(): number {
      return appGetters.getTrainTestSplit(this.$store);
    },
    trainTestSplitTimeSeries(): number {
      return appGetters.getTrainTestSplitTimeSeries(this.$store);
    },
    testingCount(): number {
      return this.totalDataCount - this.trainingCount;
    },
    testingRatio(): number {
      return 1 - this.trainingRatio;
    },
    trainingRatio(): number {
      return this.trainingCount / this.totalDataCount;
    },
    hasTimeRange(): boolean {
      return this.timeRange !== null;
    },
    baseSplit(): number {
      const routeSplit = routeGetters.getRouteTrainTestSplit(this.$store);
      return !!routeSplit
        ? routeSplit
        : this.task.includes(TaskTypes.TIME_SERIES)
        ? this.trainTestSplit
        : this.trainTestSplitTimeSeries;
    },
  },

  watch: {
    baseSplit() {
      this.trainingCount =
        Math.floor(this.totalDataCount * this.baseSplit) || 1;
    },
    totalDataCount() {
      this.trainingCount =
        Math.floor(this.totalDataCount * this.baseSplit) || 1;
    },
    timeRange() {
      if (!this.timeRange) {
        return;
      }
      const half = Math.floor((this.timeRange.max - this.timeRange.max) / 2);
      this.timestampSplitValue = new Date(
        this.secondsToMillis(this.timeRange.min + half)
      );
    },
  },

  async beforeMount() {
    const task = routeGetters.getRouteTask(this.$store);
    if (!task) return;

    await datasetActions.fetchModelingMetrics(this.$store, {
      task: this.task,
    });
    if (this.task.includes(TaskTypes.CLASSIFICATION)) {
      if (this.task.includes(TaskTypes.MULTICLASS)) {
        this.selectedMetric = "f1Macro";
      } else {
        this.selectedMetric = "f1";
      }
    } else if (this.task.includes(TaskTypes.REGRESSION)) {
      this.selectedMetric = "meanAbsoluteError";
    } else {
      this.selectedMetric = null;
    }
    this.trainingCount = Math.floor(this.totalDataCount * this.baseSplit) || 1;
  },

  methods: {
    splitSettings(splitByTime: boolean) {
      this.shouldSplitByTime = splitByTime;
      this.hasSelectedSplitType = true;
    },
    secondsToMillis(seconds: number): number {
      return seconds * 1000;
    },
    resetValues() {
      this.shouldSplitByTime = false;
      this.hasSelectedSplitType = false;
    },
    handleOk() {
      const entry = overlayRouteEntry(routeGetters.getRoute(this.$store), {
        modelLimit: this.modelLimit,
        modelTimeLimit: this.timeLimit,
        modelQuality: this.speedQuality,
        metrics: this.selectedMetric,
        trainTestSplit: this.trainingRatio,
        timestampSplit: this.hasTimeRange
          ? this.timestampSplitValue.getTime() / 1000
          : null,
      });
      this.$router.push(entry).catch((err) => console.warn(err));
    },
  },
});
</script>

<style></style>
