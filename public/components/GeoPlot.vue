<template>
  <div
    id="geo-test"
    class="geo-plot-container"
    :class="{ 'selection-mode': isSelectionMode }"
  >
    <div
      ref="geoPlot"
      class="geo-plot"
      :id="mapID"
      @keydown.esc="onEsc"
      tabindex="0"
    ></div>

    <image-drilldown
      v-if="isMultiBandImage"
      @hide="hideImageDrilldown"
      :dataFields="dataFields"
      :imageUrl="imageUrl"
      :item="item"
      :visible="isImageDrilldown"
    />
    <div
      class="selection-toggle"
      :class="{ active: isSelectionMode }"
      @click="toggleSelectionTool"
    >
      <a
        class="selection-toggle-control"
        title="Select area"
        aria-label="Select area"
      >
        <icon-base width="100%" height="100%"> <icon-crop-free /> </icon-base>
      </a>
    </div>
    <div
      class="cluster-toggle"
      :class="{ active: isClustering }"
      @click="toggleClustering"
    >
      <a class="cluster-icon" title="Cluster" aria-label="Cluster Tiles">
        <i class="fa fa-object-group fa-lg" aria-hidden="true" />
      </a>
    </div>
    <b-toast
      :id="toastId"
      :title="toastTitle"
      style="position: absolute; top: 0px; right: 0px"
      static
      no-auto-hide
    >
      <div class="geo-plot">
        <image-label
          class="image-label"
          :dataFields="dataFields"
          includedActive
          shortenLabels
          alignHorizontal
          :item="hoverItem"
        />
        <image-preview
          class="image-preview"
          :row="hoverItem"
          :image-url="hoverUrl"
          :width="imageWidth"
          :height="imageHeight"
          :type="imageType"
        ></image-preview>
      </div>
    </b-toast>
    <button
      type="button"
      class="close selection-exit"
      aria-label="Close"
      v-show="showExit"
      :style="exitStyle"
    >
      <span aria-hidden="true">&times;</span>
    </button>
  </div>
</template>

<script lang="ts">
import _ from "lodash";
import Vue from "vue";
import IconBase from "./icons/IconBase.vue";
import IconCropFree from "./icons/IconCropFree.vue";
import ImageDrilldown from "./ImageDrilldown.vue";
import ImageLabel from "./ImageLabel.vue";
import { getters as datasetGetters } from "../store/dataset/module";
import { getters as requestGetters } from "../store/requests/module";
import { getters as routeGetters } from "../store/route/module";
import { Dictionary } from "../util/dict";
import lumo from "lumo";
import BatchQuadOverlay from "../util/rendering/BatchQuadOverlay";
import {
  BatchQuadOverlayRenderer,
  EVENT_TYPES,
  DRAW_MODES,
} from "../util/rendering/BatchQuadOverlayRenderer";
import {
  TableColumn,
  TableRow,
  Highlight,
  RowSelection,
  GeoCoordinateGrouping,
  VariableSummary,
} from "../store/dataset/index";
import { updateHighlight, highlightsExist } from "../util/highlights";
import ImagePreview from "../components/ImagePreview";
import {
  LATITUDE_TYPE,
  LONGITUDE_TYPE,
  REAL_VECTOR_TYPE,
  GEOCOORDINATE_TYPE,
  MULTIBAND_IMAGE_TYPE,
} from "../util/types";
import { scaleThreshold } from "d3";
import Color from "color";
import "leaflet/dist/leaflet.css";
import "leaflet/dist/images/marker-icon.png";
import "leaflet/dist/images/marker-icon-2x.png";
import "leaflet/dist/images/marker-shadow.png";
import { BLUE_PALETTE } from "../util/color";
import { getTileHandler } from "../util/app";
const SINGLE_FIELD = 1;
const SPLIT_FIELD = 2;

interface GeoField {
  type: number;
  latField?: string;
  lngField?: string;
  field?: string;
}

interface Point {
  lat: number;
  lng: number;
  row?: TableRow;
  color?: string;
}

interface PointGroup {
  field: GeoField;
  points: Point[];
}

type TileLayer = import("leaflet").TileLayer;
type LatLngBoundsLiteral = import("leaflet").LatLngBoundsLiteral;

interface Area {
  coordinates: LatLngBoundsLiteral;
  color: string;
  imageUrl: string;
  item: TableRow;
}
// Bucket contains the clustered tile data
interface Bucket {
  coordinates: number[][]; // should be two points each with x,y expect -> number[2][2]
  meta: { selected: boolean; count: number }; // count num of tiles in bucket
}
interface Quad {
  x: number; // vertex x
  y: number; // vertex y
  r: number; // color r channel
  g: number; // color g channel
  b: number; // color b channel
  a: number; // color alpha channel
  // id's bytes is broken down into 4 channels
  iR: number; // id smallest byte
  iG: number; // id second smallest byte
  iB: number; // id second largest byte
  iA: number; // id largest byte
}
// contains the state of the map for things such as event callbacks and the quads to render
// currently there is two states tiled and clustered
interface MapState {
  onHover(id: number); // onhover callback
  onClick(id: number); // onclick callback
  quads(): Quad[]; // get quads for rendering
  init(): void; // called when state becomes current state -- essentially put any inits stuff here
  drawMode(): any; // returns DRAW_MODES
}
interface LumoPoint {
  x: number;
  y: number;
}
// Minimum pixels size of clickable target displayed on the map.
const TARGETSIZE = 6;

export default Vue.extend({
  name: "geo-plot",

  components: {
    IconBase,
    IconCropFree,
    ImageDrilldown,
    ImageLabel,
    ImagePreview,
  },

  props: {
    instanceName: String as () => string,
    dataItems: Array as () => any[],
    dataFields: Object as () => Dictionary<TableColumn>,
    summaries: Array as () => VariableSummary[],
    quadOpacity: { type: Number, default: 0.8 },
    pointOpacity: { type: Number, default: 0.8 },
    zoomThreshold: { type: Number, default: 8 },
  },

  data() {
    return {
      poiLayer: null,
      map: null,
      overlay: null,
      renderer: null,
      markers: null,
      areasMeanLng: 0,
      closeButton: null,
      startingLatLng: null,
      currentRect: null,
      selectedRect: null,
      isSelectionMode: false,
      isImageDrilldown: false,
      imageUrl: null,
      item: null,
      quadLayerId: "quad-layer",
      toastId: "geo-notifications",
      toastTitle: "",
      hoverItem: null,
      toastImg: "",
      hoverUrl: "",
      imageWidth: 128,
      imageHeight: 128,
      previousZoom: 0,
      currentState: null,
      selectionToolData: {
        startPoint: null,
        currentPoint: null,
        startPointClient: null,
        exit: { top: 0, right: 0 },
      },
      selectionToolId: "selection-tool-layer",
      showExit: false,
      pointSize: 0.025,
      isClustering: false,
    };
  },

  computed: {
    dataset(): string {
      return routeGetters.getRouteDataset(this.$store);
    },
    imageType(): string {
      return MULTIBAND_IMAGE_TYPE;
    },
    /*
     Flag to decide if we display accurate areas based on coordinates, or if they are physically
     too small, we present a circle big enough for the user to interact with them.
    */
    displayCircleMarker(): boolean {
      const pointA = this.map.latLngToContainerPoint([0, 0]);
      const pointB = this.map.latLngToContainerPoint([0, this.areasMeanLng]);
      const distanceInPixel = Math.abs(pointB.x - pointA.x);
      return distanceInPixel < TARGETSIZE;
    },

    target(): string {
      return routeGetters.getRouteTargetVariable(this.$store);
    },

    getTopVariables(): string[] {
      const variables = datasetGetters
        .getVariables(this.$store)
        .filter((v) => v.datasetName === this.dataset);
      return variables
        .map((variable) => ({
          variable: variable.colName,
          order: _.isNumber(variable.ranking)
            ? variable.ranking
            : variable.importance,
        }))
        .sort((a, b) => b.order - a.order)
        .map((r) => r.variable);
    },
    mapID(): string {
      return `map-${this.instanceName}`;
    },
    fieldSpecs(): GeoField[] {
      const variables = datasetGetters.getVariables(this.$store);

      const matches = variables.filter((v) => {
        return (
          (v.grouping && v.grouping.type === GEOCOORDINATE_TYPE) ||
          v.colType === LONGITUDE_TYPE ||
          v.colType === LATITUDE_TYPE ||
          v.colType === REAL_VECTOR_TYPE
        );
      });

      let lng = null;
      let lat = null;
      const fields = [];

      matches.forEach((match) => {
        if (match.grouping && match.grouping.type === GEOCOORDINATE_TYPE) {
          const grouping = match.grouping as GeoCoordinateGrouping;
          lng = grouping.xCol;
          lat = grouping.yCol;
        } else if (match.colType === REAL_VECTOR_TYPE) {
          fields.push({
            type: SINGLE_FIELD,
            field: match.colName,
          });
        } else {
          if (match.colType === LONGITUDE_TYPE) {
            lng = match.colName;
          }
          if (match.colType === LATITUDE_TYPE) {
            lat = match.colName;
          }
        }

        // TODO: currently we pair any two random lat / lngs, we should
        // eventually use the groupings functionality to let the user
        // group the two vars into a single point field.
        if (lng && lat) {
          fields.push({
            type: SPLIT_FIELD,
            lngField: lng,
            latField: lat,
          });
          lng = null;
          lat = null;
        }
      });

      return fields;
    },
    bucketFeatures(): Bucket[] {
      if (!this.summaries.length) {
        return [];
      }
      const features = [];
      this.summaries.forEach((summary) => {
        // compute the bucket size in degrees
        const buckets =
          summary.filtered && highlightsExist(this.$router)
            ? summary.filtered.buckets
            : summary.baseline.buckets;
        const xSize = _.toNumber(buckets[1].key) - _.toNumber(buckets[0].key);
        const ySize =
          _.toNumber(buckets[0].buckets[1].key) -
          _.toNumber(buckets[0].buckets[0].key);

        // create a feature collection from the server-supplied bucket data
        buckets.forEach((lonBucket) => {
          lonBucket.buckets.forEach((latBucket) => {
            // Don't include features with a count of 0.
            if (latBucket.count > 0) {
              const xCoord = _.toNumber(lonBucket.key);
              const yCoord = _.toNumber(latBucket.key);
              const feature = {
                coordinates: [
                  [xCoord, yCoord],
                  [xCoord + xSize, yCoord + ySize],
                ],
                meta: { selected: false, count: latBucket.count },
              };
              features.push(feature);
            }
          });
        });
      });
      // console.log(duplicateCheck);
      return features;
    },
    minBucketCount(): number {
      return Math.min(
        ...this.bucketFeatures.map((bf) => {
          return bf.meta.count;
        })
      );
    },
    maxBucketCount(): number {
      return Math.max(
        ...this.bucketFeatures.map((bf) => {
          return bf.meta.count;
        })
      );
    },
    pointGroups(): PointGroup[] {
      const groups = [];

      if (!this.dataItems) {
        return groups;
      }

      this.fieldSpecs.forEach((fieldSpec) => {
        const group = {
          field: fieldSpec,
          points: [],
        };

        group.points = this.dataItems
          .map((item) => {
            const lat = this.latValue(fieldSpec, item);
            const lng = this.lngValue(fieldSpec, item);

            if (lat !== undefined && lng !== undefined) {
              return {
                lng: lng,
                lat: lat,
                row: item,
                color: this.colorPrediction(item),
              };
            }

            return null;
          })
          .filter((point) => !!point);

        groups.push(group);
      });

      return groups;
    },

    predictedField(): string {
      const predictions = requestGetters.getActivePredictions(this.$store);
      if (predictions) {
        return predictions.predictedKey;
      }

      const solution = requestGetters.getActiveSolution(this.$store);
      return solution ? `${solution.predictedKey}` : "";
    },

    targetField(): string {
      return routeGetters.getRouteTargetVariable(this.$store);
    },

    /* Data with multiple geocordinates to be displayed as an area on the map. */
    areas(): Area[] {
      if (!this.dataItems) {
        return [];
      }
      // Array to store the longitude width (degrees) of each areas.
      const longitudes = [];

      const areas = this.dataItems.map((item) => {
        const imageUrl = this.isMultiBandImage ? item.group_id.value : null;
        const fullCoordinates = item.coordinates.value.Elements;
        if (fullCoordinates.some((x) => x === undefined)) return;

        /*
          Item store the coordinates as a list of 8 values being four pairs of [Lng, Lat],
          one for each corner of the isMultiBandImage-sensing image.

          [0,1]     [2,3]
            A-------B
            |       |
            |       |
            D-------C
          [6,7]     [4,5]
        */
        const coordinates = [
          [fullCoordinates[1].Float, fullCoordinates[0].Float], // Corner A as [Lat, Lng]
          [fullCoordinates[5].Float, fullCoordinates[4].Float], // Corner C as [Lat, Lng]
        ] as LatLngBoundsLiteral;

        const color = this.colorPrediction(item);

        longitudes.push(fullCoordinates[4].Float - fullCoordinates[0].Float); // Corner C Lng - Corner A Lng

        return { item, imageUrl, coordinates, color } as Area;
      });

      // Calculate the mean longitude of the areas.
      this.areasMeanLng =
        longitudes.reduce((acc, val) => acc + val, 0) / longitudes.length;

      return areas;
    },

    highlight(): Highlight {
      return routeGetters.getDecodedHighlight(this.$store);
    },

    mapCenter(): number[] {
      return routeGetters.getGeoCenter(this.$store);
    },

    mapZoom(): number {
      return routeGetters.getGeoZoom(this.$store);
    },

    rowSelection(): RowSelection {
      return routeGetters.getDecodedRowSelection(this.$store);
    },

    isMultiBandImage(): boolean {
      return routeGetters.isMultiBandImage(this.$store);
    },
    isGeoSpatial(): boolean {
      return routeGetters.isGeoSpatial(this.$store);
    },

    band(): string {
      return routeGetters.getBandCombinationId(this.$store);
    },
    tileHandler() {
      return getTileHandler();
    },
    tileState(): MapState {
      return {
        onHover: (id: number) => {
          if (id > this.areas.length) {
            console.error(`id: ${id} is outside of this.areas bounds`);
            return; // id outside of bounds
          }
          this.toastTitle = this.areas[id].imageUrl;
          this.hoverItem = this.areas[id].item;
          this.hoverUrl = this.areas[id].imageUrl;
          this.$bvToast.show(this.toastId);
          window.addEventListener("mousemove", this.fadeToast);
        },
        onClick: (id: number) => {
          if (id > this.areas.length || id < 0) {
            console.error(
              `id retrieved from buffer picker ${id} not within index bounds of areas.`
            );
            return;
          }
          this.showImageDrilldown(this.areas[id].imageUrl, this.areas[id].item);
        },
        quads: () => {
          return this.areaToQuads();
        },
        init: () => {
          this.renderer.setPointSize(1); // default
        },
        drawMode: () => {
          return DRAW_MODES.TRIANGLES;
        },
      };
    },
    clusterState(): MapState {
      return {
        onHover: (id: number) => {
          return;
        }, // onHover empty for cluster state
        onClick: (id: number) => {
          if (id > this.bucketFeatures.length || id < 0) {
            console.error(
              `id retrieved from buffer picker ${id} not within index bounds of areas.`
            );
            return;
          }
          const bucket = this.bucketFeatures[id];
          const point1 = this.renderer.latlngToNormalized(
            bucket.coordinates[0]
          );
          const point2 = this.renderer.latlngToNormalized(
            bucket.coordinates[1]
          );
          const center = {
            x: (point1.x + point2.x) / 2,
            y: (point1.y + point2.y) / 2,
          };
          this.map.zoomToPosition(this.zoomThreshold, center); // zoom to the center of the cluster clicked. Zoom to the point where the state switches
        },
        quads: () => {
          return this.bucketsToQuads();
        },
        init: () => {
          this.renderer.setPointSize(1); // default
        },
        drawMode: () => {
          return DRAW_MODES.TRIANGLES;
        },
      };
    },
    pointState(): MapState {
      return {
        onHover: (id: number) => {
          if (id > this.areas.length) {
            console.error(`id: ${id} is outside of this.areas bounds`);
            return; // id outside of bounds
          }
          this.toastTitle = this.areas[id].imageUrl;
          this.hoverItem = this.areas[id].item;
          this.hoverUrl = this.areas[id].imageUrl;
          this.$bvToast.show(this.toastId);
          window.addEventListener("mousemove", this.fadeToast);
        },
        onClick: (id: number) => {
          if (id > this.areas.length || id < 0) {
            console.error(
              `id retrieved from buffer picker ${id} not within index bounds of areas.`
            );
            return;
          }
          this.showImageDrilldown(this.areas[id].imageUrl, this.areas[id].item);
        },
        quads: () => {
          return this.areaToPoints();
        },
        init: () => {
          this.renderer.setPointSize(this.pointSize);
        },
        drawMode: () => {
          return DRAW_MODES.POINTS;
        },
      };
    },
    exitStyle(): string {
      return `top:${this.selectionToolData.exit.top}px; right:${this.selectionToolData.exit.right}px;`;
    },
  },
  methods: {
    createLumoMap() {
      // create map
      this.map = new lumo.Plot(`#map-select-data`, {
        continuousZoom: true,
        inertia: true,
        wraparound: true,
        zoom: 3,
        maxZoom: 11,
      });
      // WebGL CARTO Image Layer
      const base = new lumo.TileLayer({
        renderer: new lumo.ImageTileRenderer(),
      });
      // tile request function
      base.requestTile = (coord, done) => {
        // const SUBDOMAINS = ["a", "b", "c"];
        // const s = SUBDOMAINS[(coord.x + coord.y + coord.z) % SUBDOMAINS.length];
        const url = this.tileHandler.requestTile(coord.x, coord.y, coord.z);
        lumo.loadImage(url, done);
      };
      this.map.add(base);
      // Quad layer
      this.overlay = new BatchQuadOverlay();
      this.renderer = new BatchQuadOverlayRenderer();
      this.overlay.setRenderer(this.renderer);
      this.map.add(this.overlay);
      // convert this.areas to quads in normalized space and add to overlay layer
      this.currentState = this.pointState;
      this.map.on(lumo.ZOOM_END, this.onZoom);
      this.currentState.init();
      if (!this.bucketFeatures.length && !this.areas.length) {
        return; // no data
      }
      const quads = this.currentState.quads();
      // get quad set bounds
      const mapBounds = this.getBounds(quads);
      this.overlay.addQuad(
        this.quadLayerId,
        quads,
        this.currentState.drawMode()
      );

      // add listener for clicks on quads
      this.renderer.addListener(
        EVENT_TYPES.MOUSE_CLICK,
        this.currentState.onClick
      );
      this.renderer.addListener(
        EVENT_TYPES.MOUSE_HOVER,
        this.currentState.onHover
      );
      this.map.fitToBounds(mapBounds);
    },
    /**
     * toggle clustering
     */
    toggleClustering() {
      this.isClustering = !this.isClustering;
      if (this.isClustering && this.map.getZoom() < this.zoomThreshold) {
        this.currentState = this.clusterState;
        this.updateMapState();
        return;
      }
      if (!this.isClustering && this.map.getZoom() < this.zoomThreshold) {
        this.currentState = this.pointState;
        this.updateMapState();
      }
    },
    /**
     * on selection tool toggle disable or enable the quad interactions such as click or hover
     */
    toggleSelectionTool() {
      this.isSelectionMode = !this.isSelectionMode;
      if (this.isSelectionMode) {
        // disable interactions so the selection tool can interact without triggering the other interactions
        this.renderer.disableInteractions();
        this.map.on("mousedown", this.selectionToolDown);
        this.map.disablePanning();
        this.map.disableZooming();
        return;
      }
      this.overlay.removeQuad(this.selectionToolId);
      this.map.removeListener("mousedown", this.selectionToolDown);
      this.showExit = false;
      // enable interactions
      this.renderer.enableInteractions();
      this.map.enablePanning();
      this.map.enableZooming();
    },
    // mouse move clear and redraw quad with new point
    selectionToolDraw(e) {
      this.selectionToolData.currentPoint = e.pos;
      // draw current selection
      this.overlay.removeQuad(this.selectionToolId);
      this.overlay.addQuad(
        this.selectionToolId,
        this.pointsToQuad(
          this.selectionToolData.startPoint,
          this.selectionToolData.currentPoint
        ),
        DRAW_MODES.TRIANGLES
      );
    },
    // register mousemouve and up callbacks to draw the selection quad
    selectionToolDown(e) {
      this.selectionToolData.startPoint = e.pos;
      this.selectionToolData.startPointClient = e.originalEvent;
      this.showExit = false;
      this.overlay.removeQuad(this.selectionToolId);
      this.map.on("mousemove", this.selectionToolDraw);
      this.map.on("mouseup", this.selectionToolUp);
    },
    // add exit button and send selection to postgis to update data
    selectionToolUp(e) {
      this.selectionToolData.currentPoint = e.pos;
      this.map.removeListener("mousemove", this.selectionToolDraw);
      this.map.removeListener("mouseup", this.selectionToolUp);
      this.selectionToolData.exit.top = Math.min(
        e.originalEvent.layerY,
        this.selectionToolData.startPointClient.layerY
      ); // get top most y value
      const right = Math.max(
        e.originalEvent.layerX,
        this.selectionToolData.startPointClient.layerX
      ); // get right most x value
      this.selectionToolData.exit.right = e.target.canvas.clientWidth - right; // had to subtract width for some reason x is reversed in lumo
      this.showExit = true;
      // convert from normalized coordinate system to lat lng
      const p1 = this.renderer.normalizedPointToLatLng(
        this.selectionToolData.startPoint
      );
      const p2 = this.renderer.normalizedPointToLatLng(
        this.selectionToolData.currentPoint
      );
      // INVERTED LAT LNG FOR NOW -- POSSIBLE ROUTE OR DB ISSUE
      const minX = Math.min(p1.lng, p2.lng);
      const maxX = Math.max(p1.lng, p2.lng);
      const minY = Math.min(p1.lat, p2.lat);
      const maxY = Math.max(p1.lat, p2.lat);
      // send selection to PostGis
      this.createHighlight({ minX, minY, maxX, maxY });
    },
    getBounds(quads: Quad[]) {
      // set mapBounds to a single tile to start
      const mapBounds = new lumo.Bounds(
        quads[0].x,
        quads[0].x,
        quads[0].y,
        quads[0].y
      );
      // extend bounds to fit the entire quad set
      quads.forEach((q) => {
        mapBounds.extend(q);
      });
      return mapBounds;
    },

    // callback when tile is being clicked and generates drilldown.
    onTileClick(id: number) {
      if (id > this.areas.length || id < 0) {
        console.error(
          `id retrieved from buffer picker ${id} not within index bounds of areas.`
        );
        return;
      }
      this.showImageDrilldown(this.areas[id].imageUrl, this.areas[id].item);
    },
    // callback when tile is being hovered on and generates a toast notification
    async onTileHover(id: number) {
      if (id > this.areas.length) {
        console.error(`id: ${id} is outside of this.areas bounds`);
        return; // id outside of bounds
      }
      this.toastTitle = this.areas[id].imageUrl;
      this.hoverItem = this.areas[id].item;
      this.hoverUrl = this.areas[id].imageUrl;
      this.$bvToast.show(this.toastId);
      window.addEventListener("mousemove", this.fadeToast);
    },
    // fades toast after mouse is moved
    fadeToast() {
      this.$bvToast.hide(this.toastId);
      window.removeEventListener("mousemove", this.fadeToast); // remove event listener because toast is now faded
    },
    // assumes x and y are normalized points this function is for the selection tool
    pointsToQuad(p1: LumoPoint, p2: LumoPoint): Quad[] {
      const result = [];
      const id = this.renderer.idToRGBA(0); // pass in 0 as the id, currently there is only ever one selection at a time.
      const color = Color(BLUE_PALETTE[0]).rgb().object();
      const maxColorVal = 256;
      // normalize color values
      color.a = this.pointOpacity;
      color.r /= maxColorVal;
      color.g /= maxColorVal;
      color.b /= maxColorVal;
      result.push({ ...p1, ...color, ...id });
      result.push({ x: p2.x, y: p1.y, ...color, ...id });
      result.push({ ...p2, ...color, ...id });
      result.push({ ...p1, ...color, ...id });
      result.push({ x: p1.x, y: p2.y, ...color, ...id });
      result.push({ ...p2, ...color, ...id });
      return result;
    },

    // packs all data into single aligned memory array
    bucketsToQuads(): Quad[] {
      const maxVal = this.maxBucketCount;
      const minVal = this.minBucketCount;
      const d = (maxVal - minVal) / BLUE_PALETTE.length;
      const domain = BLUE_PALETTE.map((val, index) => minVal + d * (index + 1));
      const scaleColors = scaleThreshold()
        .range(BLUE_PALETTE as any)
        .domain(domain);
      const result = []; // packing array with
      this.bucketFeatures.forEach((bucket, idx) => {
        const p1 = this.renderer.latlngToNormalized([
          bucket.coordinates[0][1],
          bucket.coordinates[0][0],
        ]);
        const p2 = this.renderer.latlngToNormalized([
          bucket.coordinates[1][1],
          bucket.coordinates[1][0],
        ]);
        const color = Color(scaleColors(bucket.meta.count).toString(16))
          .rgb()
          .object(); // convert hex color to rgb
        const maxColorVal = 256;
        // normalize color values
        color.a = this.quadOpacity;
        color.r /= maxColorVal;
        color.g /= maxColorVal;
        color.b /= maxColorVal;
        const id = this.renderer.idToRGBA(idx); // separate index bytes into 4 channels iR,iG,iB,iA. Used to render the index of the object into webgl FBO
        // need to get rid of spread operators super slow
        result.push({ ...p1, ...color, ...id });
        result.push({ x: p2.x, y: p1.y, ...color, ...id });
        result.push({ ...p2, ...color, ...id });
        result.push({ ...p1, ...color, ...id });
        result.push({ x: p1.x, y: p2.y, ...color, ...id });
        result.push({ ...p2, ...color, ...id });
      });
      return result;
    },
    areaToPoints(): Quad[] {
      const result = [];
      this.areas.forEach((area, idx) => {
        const p1 = this.renderer.latlngToNormalized(area.coordinates[0]);
        const p2 = this.renderer.latlngToNormalized(area.coordinates[1]);
        const centerPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        const color = Color(area.color).rgb().object(); // convert hex color to rgb
        const maxVal = 255;
        // normalize color values
        color.a = this.pointOpacity;
        color.r /= maxVal;
        color.g /= maxVal;
        color.b /= maxVal;
        const id = this.renderer.idToRGBA(idx); // separate index bytes into 4 channels iR,iG,iB,iA. Used to render the index of the object into webgl FBO
        // need to get rid of spread operators super slow
        result.push({ ...centerPoint, ...color, ...id });
      });
      return result;
    },
    // packs all data into single aligned memory array
    areaToQuads(): Quad[] {
      const result = [];
      this.areas.forEach((area, idx) => {
        const p1 = this.renderer.latlngToNormalized(area.coordinates[0]);
        const p2 = this.renderer.latlngToNormalized(area.coordinates[1]);
        const color = Color(area.color).rgb().object(); // convert hex color to rgb
        const maxVal = 255;
        // normalize color values
        color.a = this.quadOpacity;
        color.r /= maxVal;
        color.g /= maxVal;
        color.b /= maxVal;
        const id = this.renderer.idToRGBA(idx); // separate index bytes into 4 channels iR,iG,iB,iA. Used to render the index of the object into webgl FBO
        // need to get rid of spread operators super slow
        result.push({ ...p1, ...color, ...id });
        result.push({ x: p2.x, y: p1.y, ...color, ...id });
        result.push({ ...p2, ...color, ...id });
        result.push({ ...p1, ...color, ...id });
        result.push({ x: p1.x, y: p2.y, ...color, ...id });
        result.push({ ...p2, ...color, ...id });
      });
      return result;
    },
    // callback when zooming on map
    onZoom() {
      const zoom = this.map.getZoom();
      const wasPoints =
        zoom >= this.zoomThreshold && this.previousZoom < this.zoomThreshold;
      const wasTiled =
        zoom < this.zoomThreshold && this.previousZoom >= this.zoomThreshold;
      this.previousZoom = this.map.getZoom();
      // check if map should be rendering clustered tiles
      if (wasPoints) {
        this.currentState = this.tileState;
        this.updateMapState();
        return;
      }
      if (wasTiled) {
        this.currentState = this.isClustering
          ? this.clusterState
          : this.pointState;
        this.updateMapState();
        return;
      }
    },
    // called after state changes and map needs to update
    updateMapState() {
      this.overlay.clearQuads();
      this.renderer.clearListeners();
      this.currentState.init();
      this.overlay.addQuad(
        this.quadLayerId,
        this.currentState.quads(),
        this.currentState.drawMode()
      );
      this.renderer.addListener(
        EVENT_TYPES.MOUSE_CLICK,
        this.currentState.onClick
      );
      this.renderer.addListener(
        EVENT_TYPES.MOUSE_HOVER,
        this.currentState.onHover
      );
    },

    onEsc() {
      if (this.isSelectionMode) {
        this.toggleSelectionTool();
      }
    },

    createHighlight(value: {
      minX: number;
      maxX: number;
      minY: number;
      maxY: number;
    }) {
      if (
        this.highlight &&
        this.highlight.value.minX === value.minX &&
        this.highlight.value.maxX === value.maxX &&
        this.highlight.value.minY === value.minY &&
        this.highlight.value.maxY === value.maxY
      ) {
        // dont push existing highlight
        return;
      }

      // TODO: support filtering multiple vars?
      const fieldSpec = this.fieldSpecs[0];
      let key = "";
      if (!!fieldSpec) {
        key =
          fieldSpec.type === SINGLE_FIELD
            ? fieldSpec.field
            : this.fieldHash(fieldSpec);
      } else if (!!this.summaries[0].key) {
        key = this.summaries[0].key;
      } else {
        console.error("Error createHighlight no available key");
        return;
      }

      updateHighlight(this.$router, {
        context: this.instanceName,
        dataset: this.dataset,
        key: key,
        value: value,
      });
    },

    drawFilters() {
      // TODO: impl this
    },

    lngValue(fieldSpec: GeoField, row: TableRow): number {
      if (fieldSpec.type === SINGLE_FIELD) {
        return row[fieldSpec.field].Elements[0].Float;
      }
      return row[fieldSpec.lngField].value;
    },

    latValue(fieldSpec: GeoField, row: TableRow): number {
      if (fieldSpec.type === SINGLE_FIELD) {
        return row[fieldSpec.field].Elements[1].Float;
      }
      return row[fieldSpec.latField].value;
    },

    fieldHash(fieldSpec: GeoField): string {
      if (fieldSpec.type === SINGLE_FIELD) {
        return fieldSpec.field;
      }
      return fieldSpec.lngField + ":" + fieldSpec.latField;
    },

    showImageDrilldown(imageUrl: string, item: TableRow) {
      this.imageUrl = imageUrl ?? null;
      this.item = item ?? null;
      this.isImageDrilldown = true;
    },

    hideImageDrilldown() {
      this.isImageDrilldown = false;
    },

    colorPrediction(item: any) {
      let color = "#255DCC"; // Default

      if (item[this.targetField] && item[this.predictedField]) {
        color =
          item[this.targetField].value === item[this.predictedField].value
            ? "#03c003" // Correct: green.
            : "#be0000"; // Incorrect: red.
      }

      return color;
    },
    onNewData() {
      // clear quads
      this.overlay.clearQuads();
      // remove exit button for selection quad
      this.showExit = false;
      // create quads from latlng
      const quads = this.currentState.quads();
      if (!quads.length) {
        return;
      }
      // get bounds of quad set
      const mapBounds = this.getBounds(quads);
      // add the batched quads to a single layer on the overlay
      this.overlay.addQuad(
        this.quadLayerId,
        quads,
        this.currentState.drawMode()
      );
      // fit map to the quad set
      this.map.fitToBounds(mapBounds);
    },
  },

  watch: {
    summaries(cur, prev) {
      if (!prev.length && this.isClustering) {
        if (this.map.getZoom() < this.zoomThreshold) {
          this.currentState = this.clusterState;
          this.updateMapState();
        }
      } else {
        this.onNewData();
      }
    },
  },

  mounted() {
    this.createLumoMap();
  },
});
</script>

<style>
.geo-plot-container,
.geo-plot {
  position: relative;
  z-index: 0;
  width: 100%;
  height: 100%;
  bottom: 0;
}

.geo-plot-container .selection-toggle {
  position: absolute;
  z-index: 999;
  top: 80px;
  left: 10px;
  width: 34px;
  height: 34px;
  background-color: #fff;
  border: 2px solid rgba(0, 0, 0, 0.2);
  background-clip: padding-box;
  text-align: center;
  border-radius: 4px;
}

.cluster-toggle {
  position: absolute;
  z-index: 999;
  top: 40px;
  left: 10px;
  width: 34px;
  height: 34px;
  background-color: #fff;
  border: 2px solid rgba(0, 0, 0, 0.2);
  background-clip: padding-box;
  text-align: center;
  border-radius: 4px;
}
.cluster-icon {
  width: 30px;
  height: 30px;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
}
.cluster-toggle:hover {
  background-color: #f4f4f4;
}
.cluster-toggle.active {
  color: #26b8d1;
}
.geo-plot-container .selection-toggle:hover {
  background-color: #f4f4f4;
}

.geo-plot-container .selection-toggle-control {
  text-decoration: none;
  color: black;
  cursor: pointer;
}

.geo-plot-container .selection-toggle-control:hover {
  text-decoration: none;
  color: black;
}

.geo-plot-container .selection-toggle.active {
  position: absolute;
}

.geo-plot-container .selection-toggle.active .selection-toggle-control {
  color: #26b8d1;
}

.geo-plot-container.selection-mode .geo-plot {
  cursor: crosshair;
}

path.selected {
  stroke-width: 2;
  fill-opacity: 0.4;
}

.geo-plot .markerPoint:hover {
  filter: brightness(1.2);
}

.geo-plot .markerPoint.selected {
  filter: hue-rotate(150deg);
}

.leaflet-tooltip {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 300px !important;
}

.geo-close-button {
  position: absolute;
  width: 24px;
  height: 24px;
  text-align: center;
  line-height: 24px;

  left: 8px;
  top: -24px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background-color: #fff;
  color: #000;
  cursor: pointer;
}

.geo-close-button:hover {
  background-color: #f4f4f4;
}
.geo-toast {
  position: absolute;
  top: 0px;
  right: 0px;
}
.image-label {
  position: absolute;
  left: 2px;
  top: 2px;
  z-index: 1;
}
.selection-exit {
  position: absolute;
}
</style>
