<template>
  <div
    id="geo-test"
    class="geo-plot-container"
    :class="{ 'selection-mode': isSelectionMode }"
  >
    <div
      class="geo-plot"
      :id="mapID"
      @mousedown="onMouseDown"
      @mouseup="onMouseUp"
      @mousemove="onMouseMove"
      @keydown.esc="onEsc"
    ></div>

    <image-drilldown
      v-if="isRemoteSensing"
      @hide="hideImageDrilldown"
      :dataFields="dataFields"
      :imageUrl="imageUrl"
      :item="item"
      :visible="isImageDrilldown"
    />
    <!--Commented out until feature is working again-->
    <!--<div
      class="selection-toggle"
      :class="{ active: isSelectionMode }"
      @click="isSelectionMode = !isSelectionMode"
    >
      <a
        class="selection-toggle-control"
        title="Select area"
        aria-label="Select area"
      >
        <icon-base width="100%" height="100%"> <icon-crop-free /> </icon-base>
      </a>
    </div> -->
    <b-toast
      :id="toastId"
      :title="toastTitle"
      style="position: absolute; top: 0px; right: 0px"
      static
      no-auto-hide
    >
      <div class="geo-plot">
        <image-label
          class="image-label"
          :dataFields="dataFields"
          includedActive
          shortenLabels
          alignHorizontal
          :item="hoverItem"
        />
        <image-preview
          class="image-preview"
          :row="hoverItem"
          :image-url="hoverUrl"
          :width="imageWidth"
          :height="imageHeight"
          type="remote_sensing"
        ></image-preview>
      </div>
    </b-toast>
  </div>
</template>

<script lang="ts">
import _ from "lodash";
import $ from "jquery";
import leaflet, {
  MarkerOptions,
  LatLngTuple,
  LatLngBounds,
  CircleMarkerOptions,
} from "leaflet";
import Vue from "vue";
import IconBase from "./icons/IconBase.vue";
import IconCropFree from "./icons/IconCropFree.vue";
import ImageDrilldown from "./ImageDrilldown.vue";
import ImageLabel from "./ImageLabel.vue";
import { getters as datasetGetters } from "../store/dataset/module";
import { getters as requestGetters } from "../store/requests/module";
import { getters as routeGetters } from "../store/route/module";
import { Dictionary } from "../util/dict";
import lumo from "lumo";
import BatchQuadOverlay from "../util/rendering/BatchQuadOverlay";
import {
  BatchQuadOverlayRenderer,
  EVENT_TYPES,
} from "../util/rendering/BatchQuadOverlayRenderer";
import {
  TableColumn,
  TableRow,
  D3M_INDEX_FIELD,
  Highlight,
  RowSelection,
  GeoCoordinateGrouping,
  VariableSummary,
} from "../store/dataset/index";
import { updateHighlight, clearHighlight } from "../util/highlights";
import {
  addRowSelection,
  removeRowSelection,
  isRowSelected,
} from "../util/row";
import ImagePreview from "../components/ImagePreview";
import {
  LATITUDE_TYPE,
  LONGITUDE_TYPE,
  REAL_VECTOR_TYPE,
  GEOCOORDINATE_TYPE,
} from "../util/types";
import { scaleThreshold } from "d3";
import Color from "color";
import "leaflet/dist/leaflet.css";
import "leaflet/dist/images/marker-icon.png";
import "leaflet/dist/images/marker-icon-2x.png";
import "leaflet/dist/images/marker-shadow.png";
import { BLUE_PALETTE } from "../util/color";

const SINGLE_FIELD = 1;
const SPLIT_FIELD = 2;
const CLOSE_BUTTON_CLASS = "geo-close-button";
const CLOSE_ICON_CLASS = "fa-times";

interface GeoField {
  type: number;
  latField?: string;
  lngField?: string;
  field?: string;
}

interface Point {
  lat: number;
  lng: number;
  row?: TableRow;
  color?: string;
}

interface PointGroup {
  field: GeoField;
  points: Point[];
}

type TileLayer = import("leaflet").TileLayer;
type LatLngBoundsLiteral = import("leaflet").LatLngBoundsLiteral;

interface Area {
  coordinates: LatLngBoundsLiteral;
  color: string;
  imageUrl: string;
  item: TableRow;
}
// Bucket contains the clustered tile data
interface Bucket {
  coordinates: number[][]; // should be two points each with x,y expect -> number[2][2]
  meta: { selected: boolean; count: number }; // count num of tiles in bucket
}
interface Quad {
  x: number; // vertex x
  y: number; // vertex y
  r: number; // color r channel
  g: number; // color g channel
  b: number; // color b channel
  a: number; // color alpha channel
  // id's bytes is broken down into 4 channels
  iR: number; // id smallest byte
  iG: number; // id second smallest byte
  iB: number; // id second largest byte
  iA: number; // id largest byte
}
// contains the state of the map for things such as event callbacks and the quads to render
// currently there is two states tiled and clustered
interface MapState {
  onHover(id: number);
  onClick(id: number);
  quads(): Quad[];
}
// Minimum pixels size of clickable target displayed on the map.
const TARGETSIZE = 6;

export default Vue.extend({
  name: "geo-plot",

  components: {
    IconBase,
    IconCropFree,
    ImageDrilldown,
    ImageLabel,
    ImagePreview,
  },

  props: {
    instanceName: String as () => string,
    dataItems: Array as () => any[],
    dataFields: Object as () => Dictionary<TableColumn>,
    summaries: Array as () => VariableSummary[],
    quadOpacity: { type: Number, default: 0.8 },
    zoomThreshold: { type: Number, default: 8 },
  },

  data() {
    return {
      poiLayer: null,
      map: null,
      overlay: null,
      renderer: null,
      markers: null,
      areasMeanLng: 0,
      closeButton: null,
      startingLatLng: null,
      currentRect: null,
      selectedRect: null,
      isSelectionMode: false,
      isImageDrilldown: false,
      imageUrl: null,
      item: null,
      polygonLayerId: "polygon-layer",
      toastId: "geo-notifications",
      toastTitle: "",
      hoverItem: null,
      toastImg: "",
      hoverUrl: "",
      imageWidth: 128,
      imageHeight: 128,
      previousZoom: 0,
      currentState: null,
    };
  },

  computed: {
    dataset(): string {
      return routeGetters.getRouteDataset(this.$store);
    },

    /*
     Flag to decide if we display accurate areas based on coordinates, or if they are physically
     too small, we present a circle big enough for the user to interact with them.
    */
    displayCircleMarker(): boolean {
      const pointA = this.map.latLngToContainerPoint([0, 0]);
      const pointB = this.map.latLngToContainerPoint([0, this.areasMeanLng]);
      const distanceInPixel = Math.abs(pointB.x - pointA.x);
      return distanceInPixel < TARGETSIZE;
    },

    target(): string {
      return routeGetters.getRouteTargetVariable(this.$store);
    },

    getTopVariables(): string[] {
      const variables = datasetGetters
        .getVariables(this.$store)
        .filter((v) => v.datasetName === this.dataset);
      return variables
        .map((variable) => ({
          variable: variable.colName,
          order: _.isNumber(variable.ranking)
            ? variable.ranking
            : variable.importance,
        }))
        .sort((a, b) => b.order - a.order)
        .map((r) => r.variable);
    },
    mapID(): string {
      return `map-${this.instanceName}`;
    },
    fieldSpecs(): GeoField[] {
      const variables = datasetGetters.getVariables(this.$store);

      const matches = variables.filter((v) => {
        return (
          (v.grouping && v.grouping.type === GEOCOORDINATE_TYPE) ||
          v.colType === LONGITUDE_TYPE ||
          v.colType === LATITUDE_TYPE ||
          v.colType === REAL_VECTOR_TYPE
        );
      });

      let lng = null;
      let lat = null;
      const fields = [];

      matches.forEach((match) => {
        if (match.grouping && match.grouping.type === GEOCOORDINATE_TYPE) {
          const grouping = match.grouping as GeoCoordinateGrouping;
          lng = grouping.xCol;
          lat = grouping.yCol;
        } else if (match.colType === REAL_VECTOR_TYPE) {
          fields.push({
            type: SINGLE_FIELD,
            field: match.colName,
          });
        } else {
          if (match.colType === LONGITUDE_TYPE) {
            lng = match.colName;
          }
          if (match.colType === LATITUDE_TYPE) {
            lat = match.colName;
          }
        }

        // TODO: currently we pair any two random lat / lngs, we should
        // eventually use the groupings functionality to let the user
        // group the two vars into a single point field.
        if (lng && lat) {
          fields.push({
            type: SPLIT_FIELD,
            lngField: lng,
            latField: lat,
          });
          lng = null;
          lat = null;
        }
      });

      return fields;
    },
    bucketFeatures(): Bucket[] {
      if (!this.summaries.length) {
        return [];
      }
      const features = [];
      this.summaries.forEach((summary) => {
        // compute the bucket size in degrees
        const buckets = summary.filtered
          ? summary.filtered.buckets
          : summary.baseline.buckets;
        const xSize = _.toNumber(buckets[1].key) - _.toNumber(buckets[0].key);
        const ySize =
          _.toNumber(buckets[0].buckets[1].key) -
          _.toNumber(buckets[0].buckets[0].key);

        // create a feature collection from the server-supplied bucket data
        buckets.forEach((lonBucket) => {
          lonBucket.buckets.forEach((latBucket) => {
            // Don't include features with a count of 0.
            if (latBucket.count > 0) {
              const xCoord = _.toNumber(lonBucket.key);
              const yCoord = _.toNumber(latBucket.key);
              const feature = {
                coordinates: [
                  [xCoord, yCoord],
                  [xCoord + xSize, yCoord + ySize],
                ],
                meta: { selected: false, count: latBucket.count },
              };

              features.push(feature);
            }
          });
        });
      });
      return features;
    },
    minBucketCount(): number {
      return Math.min(
        ...this.bucketFeatures.map((bf) => {
          return bf.meta.count;
        })
      );
    },
    maxBucketCount(): number {
      return Math.max(
        ...this.bucketFeatures.map((bf) => {
          return bf.meta.count;
        })
      );
    },
    pointGroups(): PointGroup[] {
      const groups = [];

      if (!this.dataItems) {
        return groups;
      }

      this.fieldSpecs.forEach((fieldSpec) => {
        const group = {
          field: fieldSpec,
          points: [],
        };

        group.points = this.dataItems
          .map((item) => {
            const lat = this.latValue(fieldSpec, item);
            const lng = this.lngValue(fieldSpec, item);

            if (lat !== undefined && lng !== undefined) {
              return {
                lng: lng,
                lat: lat,
                row: item,
                color: this.colorPrediction(item),
              };
            }

            return null;
          })
          .filter((point) => !!point);

        groups.push(group);
      });

      return groups;
    },

    predictedField(): string {
      const predictions = requestGetters.getActivePredictions(this.$store);
      if (predictions) {
        return predictions.predictedKey;
      }

      const solution = requestGetters.getActiveSolution(this.$store);
      return solution ? `${solution.predictedKey}` : "";
    },

    targetField(): string {
      return routeGetters.getRouteTargetVariable(this.$store);
    },

    /* Data with multiple geocordinates to be displayed as an area on the map. */
    areas(): Area[] {
      if (!this.dataItems) {
        return [];
      }
      // Array to store the longitude width (degrees) of each areas.
      const longitudes = [];

      const areas = this.dataItems.map((item) => {
        const imageUrl = this.isRemoteSensing ? item.group_id.value : null;
        const fullCoordinates = item.coordinates.value.Elements;
        if (fullCoordinates.some((x) => x === undefined)) return;

        /*
          Item store the coordinates as a list of 8 values being four pairs of [Lng, Lat],
          one for each corner of the remote-sensing image.

          [0,1]     [2,3]
            A-------B
            |       |
            |       |
            D-------C
          [6,7]     [4,5]
        */
        const coordinates = [
          [fullCoordinates[1].Float, fullCoordinates[0].Float], // Corner A as [Lat, Lng]
          [fullCoordinates[5].Float, fullCoordinates[4].Float], // Corner C as [Lat, Lng]
        ] as LatLngBoundsLiteral;

        const color = this.colorPrediction(item);

        longitudes.push(fullCoordinates[4].Float - fullCoordinates[0].Float); // Corner C Lng - Corner A Lng

        return { item, imageUrl, coordinates, color } as Area;
      });

      // Calculate the mean longitude of the areas.
      this.areasMeanLng =
        longitudes.reduce((acc, val) => acc + val, 0) / longitudes.length;

      return areas;
    },

    highlight(): Highlight {
      return routeGetters.getDecodedHighlight(this.$store);
    },

    mapCenter(): number[] {
      return routeGetters.getGeoCenter(this.$store);
    },

    mapZoom(): number {
      return routeGetters.getGeoZoom(this.$store);
    },

    rowSelection(): RowSelection {
      return routeGetters.getDecodedRowSelection(this.$store);
    },

    isRemoteSensing(): boolean {
      return routeGetters.isRemoteSensing(this.$store);
    },
    isGeoSpatial(): boolean {
      return routeGetters.isGeoSpatial(this.$store);
    },

    /* Base layer for the map. */
    baseLayer(): TileLayer {
      const URL = "http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png";
      return leaflet.tileLayer(URL);
    },

    band(): string {
      return routeGetters.getBandCombinationId(this.$store);
    },
    tileState(): MapState {
      return {
        onHover: (id: number) => {
          if (id > this.areas.length) {
            console.error(`id: ${id} is outside of this.areas bounds`);
            return; // id outside of bounds
          }
          this.toastTitle = this.areas[id].imageUrl;
          this.hoverItem = this.areas[id].item;
          this.hoverUrl = this.areas[id].imageUrl;
          this.$bvToast.show(this.toastId);
          window.addEventListener("mousemove", this.fadeToast);
        },
        onClick: (id: number) => {
          if (id > this.areas.length || id < 0) {
            console.error(
              `id retrieved from buffer picker ${id} not within index bounds of areas.`
            );
            return;
          }
          this.showImageDrilldown(this.areas[id].imageUrl, this.areas[id].item);
        },
        quads: () => {
          return this.areaToQuads();
        },
      };
    },
    clusterState(): MapState {
      return {
        onHover: (id: number) => {
          return;
        }, // onHover empty for cluster state
        onClick: (id: number) => {
          if (id > this.bucketFeatures.length || id < 0) {
            console.error(
              `id retrieved from buffer picker ${id} not within index bounds of areas.`
            );
            return;
          }
          const bucket = this.bucketFeatures[id];
          const point1 = this.renderer.latlngToNormalized(
            bucket.coordinates[0]
          );
          const point2 = this.renderer.latlngToNormalized(
            bucket.coordinates[1]
          );
          const center = {
            x: (point1.x + point2.x) / 2,
            y: (point1.y + point2.y) / 2,
          };
          this.map.zoomToPosition(this.zoomThreshold, center); // zoom to the center of the cluster clicked. Zoom to the point where the state switches
        },
        quads: () => {
          return this.bucketsToQuads();
        },
      };
    },
  },
  methods: {
    createLumoMap() {
      // create map
      this.map = new lumo.Plot(`#map-select-data`, {
        continuousZoom: true,
        inertia: true,
        wraparound: true,
        zoom: 3,
        maxZoom: 11,
      });
      // WebGL CARTO Image Layer
      const base = new lumo.TileLayer({
        renderer: new lumo.ImageTileRenderer(),
      });
      // tile request function
      base.requestTile = (coord, done) => {
        const SUBDOMAINS = ["a", "b", "c"];
        const s = SUBDOMAINS[(coord.x + coord.y + coord.z) % SUBDOMAINS.length];
        const url = `https:/${s}.basemaps.cartocdn.com/light_all/${coord.xyz()}.png`;
        lumo.loadImage(url, done);
      };
      this.map.add(base);
      // Quad layer
      this.overlay = new BatchQuadOverlay();
      this.renderer = new BatchQuadOverlayRenderer();
      this.overlay.setRenderer(this.renderer);
      this.map.add(this.overlay);
      // convert this.areas to quads in normalized space and add to overlay layer
      if (!this.bucketFeatures.length) {
        this.currentState = this.tileState;
      } else {
        this.currentState = this.clusterState;
        this.map.on(lumo.ZOOM_END, this.onZoom);
      }
      if (!this.bucketFeatures.length && !this.areas.length) {
        return; // no data
      }
      const quads = this.currentState.quads();
      // get quad set bounds
      const mapBounds = this.getBounds(quads);
      this.overlay.addQuad(this.polygonLayerId, quads);

      // add listener for clicks on quads
      this.renderer.addListener(
        EVENT_TYPES.MOUSE_CLICK,
        this.currentState.onClick
      );
      this.renderer.addListener(
        EVENT_TYPES.MOUSE_HOVER,
        this.currentState.onHover
      );
      this.map.fitToBounds(mapBounds);
    },
    getBounds(quads: Quad[]) {
      // set mapBounds to a single tile to start
      const mapBounds = new lumo.Bounds(
        quads[0].x,
        quads[1].x,
        quads[0].y,
        quads[1].y
      );
      // extend bounds to fit the entire quad set
      quads.forEach((q) => {
        mapBounds.extend(q);
      });
      return mapBounds;
    },

    // callback when tile is being clicked and generates drilldown.
    onTileClick(id: number) {
      if (id > this.areas.length || id < 0) {
        console.error(
          `id retrieved from buffer picker ${id} not within index bounds of areas.`
        );
        return;
      }
      this.showImageDrilldown(this.areas[id].imageUrl, this.areas[id].item);
    },
    // callback when tile is being hovered on and generates a toast notification
    async onTileHover(id: number) {
      if (id > this.areas.length) {
        console.error(`id: ${id} is outside of this.areas bounds`);
        return; // id outside of bounds
      }
      this.toastTitle = this.areas[id].imageUrl;
      this.hoverItem = this.areas[id].item;
      this.hoverUrl = this.areas[id].imageUrl;
      this.$bvToast.show(this.toastId);
      window.addEventListener("mousemove", this.fadeToast);
    },
    // fades toast after mouse is moved
    fadeToast() {
      this.$bvToast.hide(this.toastId);
      window.removeEventListener("mousemove", this.fadeToast); // remove event listener because toast is now faded
    },
    bucketsToQuads(): Quad[] {
      const maxVal = this.maxBucketCount;
      const minVal = this.minBucketCount;
      const d = (maxVal - minVal) / BLUE_PALETTE.length;
      const domain = BLUE_PALETTE.map((val, index) => minVal + d * (index + 1));
      const scaleColors = scaleThreshold()
        .range(BLUE_PALETTE as any)
        .domain(domain);
      const result = [];
      this.bucketFeatures.forEach((bucket, idx) => {
        const p1 = this.renderer.latlngToNormalized(bucket.coordinates[0]);
        const p2 = this.renderer.latlngToNormalized(bucket.coordinates[1]);
        const val = scaleColors(bucket.meta.count).toString(16);
        const color = Color(scaleColors(bucket.meta.count).toString(16))
          .rgb()
          .object(); // convert hex color to rgb
        const maxColorVal = 255;
        // normalize color values
        color.a = 1;
        color.r /= maxColorVal;
        color.g /= maxColorVal;
        color.b /= maxColorVal;
        const id = this.renderer.idToRGBA(idx); // separate index bytes into 4 channels iR,iG,iB,iA. Used to render the index of the object into webgl FBO
        // need to get rid of spread operators super slow
        result.push({ ...p1, ...color, ...id });
        result.push({ x: p2.x, y: p1.y, ...color, ...id });
        result.push({ ...p2, ...color, ...id });
        result.push({ ...p1, ...color, ...id });
        result.push({ x: p1.x, y: p2.y, ...color, ...id });
        result.push({ ...p2, ...color, ...id });
      });
      return result;
    },
    areaToQuads(): Quad[] {
      const result = [];
      this.areas.forEach((area, idx) => {
        const p1 = this.renderer.latlngToNormalized([
          area.coordinates[0][1],
          area.coordinates[0][0],
        ]); // lat,lng ->lng,lat
        const p2 = this.renderer.latlngToNormalized([
          area.coordinates[1][1],
          area.coordinates[1][0],
        ]); // lat,lng ->lng,lat
        const color = Color(area.color).rgb().object(); // convert hex color to rgb
        const maxVal = 255;
        // normalize color values
        color.a = this.quadOpacity;
        color.r /= maxVal;
        color.g /= maxVal;
        color.b /= maxVal;
        const id = this.renderer.idToRGBA(idx); // separate index bytes into 4 channels iR,iG,iB,iA. Used to render the index of the object into webgl FBO
        // need to get rid of spread operators super slow
        result.push({ ...p1, ...color, ...id });
        result.push({ x: p2.x, y: p1.y, ...color, ...id });
        result.push({ ...p2, ...color, ...id });
        result.push({ ...p1, ...color, ...id });
        result.push({ x: p1.x, y: p2.y, ...color, ...id });
        result.push({ ...p2, ...color, ...id });
      });
      return result;
    },
    // callback when zooming on map
    onZoom() {
      const zoom = this.map.getZoom();
      const wasClustered =
        zoom >= this.zoomThreshold && this.previousZoom < this.zoomThreshold;
      const wasTiled =
        zoom < this.zoomThreshold && this.previousZoom >= this.zoomThreshold;
      this.previousZoom = this.map.getZoom();
      // check if map should be rendering clustered tiles
      if (wasClustered) {
        this.currentState = this.tileState;
        this.updateMap();
        return;
      }
      if (wasTiled) {
        this.currentState = this.clusterState;
        this.updateMap();
        return;
      }
    },
    // called after state changes and map needs to update
    updateMap() {
      this.overlay.clearQuads();
      this.renderer.clearListeners();
      this.overlay.addQuad(this.polygonLayerId, this.currentState.quads());
      this.renderer.addListener(
        EVENT_TYPES.MOUSE_CLICK,
        this.currentState.onClick
      );
      this.renderer.addListener(
        EVENT_TYPES.MOUSE_HOVER,
        this.currentState.onHover
      );
    },
    clearSelectionRect() {
      if (this.selectedRect) {
        this.selectedRect.remove();
        this.selectedRect = null;
      }
      if (this.currentRect) {
        this.currentRect.remove();
        this.currentRect = null;
      }
      if (this.closeButton) {
        this.closeButton.remove();
        this.closeButton = null;
      }
    },

    onMouseDown(event: MouseEvent) {
      const mapEventTarget = event.target as HTMLElement;

      // check if mapEventTarget is the close button or icon
      if (
        mapEventTarget.classList.contains(CLOSE_BUTTON_CLASS) ||
        mapEventTarget.classList.contains(CLOSE_ICON_CLASS)
      ) {
        this.clearSelection();
        this.selectedRect.remove();
        this.selectedRect = null;
        this.closeButton.remove();
        this.closeButton = null;
        return;
      }

      if (this.isSelectionMode) {
        this.clearSelectionRect();

        const offset = $(this.map.getContainer()).offset();
        this.startingLatLng = this.map.containerPointToLatLng({
          x: event.pageX - offset.left,
          y: event.pageY - offset.top,
        });

        const bounds = [this.startingLatLng, this.startingLatLng];
        this.currentRect = leaflet.rectangle(bounds, {
          color: "#255DCC",
          weight: 1,
          bubblingMouseEvents: false,
        });
        this.currentRect.on("click", (e) => {
          this.setSelection(e.target);
        });
        this.currentRect.addTo(this.map);

        // enable drawing mode
        // this.map.off('click', this.clearSelection);
        this.map.dragging.disable();
      }
    },

    onMouseUp(event: MouseEvent) {
      if (this.currentRect) {
        this.setSelection(this.currentRect);
        this.currentRect = null;

        // disable drawing mode
        this.map.dragging.enable();
        // this.map.on('click', this.clearSelection);
      }
    },

    onMouseMove(event: MouseEvent) {
      if (this.currentRect) {
        const offset = $(this.map.getContainer()).offset();
        const latLng = this.map.containerPointToLatLng({
          x: event.pageX - offset.left,
          y: event.pageY - offset.top,
        });
        const bounds = [this.startingLatLng, latLng];
        this.currentRect.setBounds(bounds);
      }
    },

    onEsc() {
      if (this.currentRect) {
        this.clearSelectionRect();
        // disable drawing mode
        this.map.dragging.enable();
      }
    },

    setSelection(rect) {
      this.clearSelection();

      this.selectedRect = rect;
      const $selected = $(this.selectedRect._path);
      $selected.addClass("selected");

      const ne = rect.getBounds().getNorthEast();
      const sw = rect.getBounds().getSouthWest();
      const icon = leaflet.divIcon({
        className: CLOSE_BUTTON_CLASS,
        iconSize: null,
        html: `<i class="fa ${CLOSE_ICON_CLASS}"></i>`,
      });
      this.closeButton = leaflet.marker([ne.lat, ne.lng], {
        icon: icon,
      });
      this.closeButton.addTo(this.map);
      this.createHighlight({
        minX: sw.lng,
        maxX: ne.lng,
        minY: sw.lat,
        maxY: ne.lat,
      });
    },

    clearSelection() {
      if (this.selectedRect) {
        $(this.selectedRect._path).removeClass("selected");
        clearHighlight(this.$router);
      }
      if (this.closeButton) {
        this.closeButton.remove();
      }
    },

    createHighlight(value: {
      minX: number;
      maxX: number;
      minY: number;
      maxY: number;
    }) {
      if (
        this.highlight &&
        this.highlight.value.minX === value.minX &&
        this.highlight.value.maxX === value.maxX &&
        this.highlight.value.minY === value.minY &&
        this.highlight.value.maxY === value.maxY
      ) {
        // dont push existing highlight
        return;
      }

      // TODO: support filtering multiple vars?
      const fieldSpec = this.fieldSpecs[0];
      const key =
        fieldSpec.type === SINGLE_FIELD
          ? fieldSpec.field
          : this.fieldHash(fieldSpec);

      updateHighlight(this.$router, {
        context: this.instanceName,
        dataset: this.dataset,
        key: key,
        value: value,
      });
    },

    drawHighlight() {
      if (
        this.highlight &&
        this.highlight.value.minX !== undefined &&
        this.highlight.value.maxX !== undefined &&
        this.highlight.value.minY !== undefined &&
        this.highlight.value.maxY !== undefined
      ) {
        const rect = leaflet.rectangle(
          [
            [this.highlight.value.minY, this.highlight.value.minX],
            [this.highlight.value.maxY, this.highlight.value.maxX],
          ],
          {
            color: "#255DCC",
            weight: 1,
            bubblingMouseEvents: false,
          }
        );
        rect.on("click", (e) => {
          this.setSelection(e.target);
        });
        rect.addTo(this.map);

        this.setSelection(rect);
      }
    },

    drawFilters() {
      // TODO: impl this
    },

    lngValue(fieldSpec: GeoField, row: TableRow): number {
      if (fieldSpec.type === SINGLE_FIELD) {
        return row[fieldSpec.field].Elements[0].Float;
      }
      return row[fieldSpec.lngField].value;
    },

    latValue(fieldSpec: GeoField, row: TableRow): number {
      if (fieldSpec.type === SINGLE_FIELD) {
        return row[fieldSpec.field].Elements[1].Float;
      }
      return row[fieldSpec.latField].value;
    },

    fieldHash(fieldSpec: GeoField): string {
      if (fieldSpec.type === SINGLE_FIELD) {
        return fieldSpec.field;
      }
      return fieldSpec.lngField + ":" + fieldSpec.latField;
    },

    toggleSelection(event) {
      const marker = event.target;
      const row = marker.options.row;
      if (!isRowSelected(this.rowSelection, row[D3M_INDEX_FIELD])) {
        addRowSelection(
          this.$router,
          this.instanceName,
          this.rowSelection,
          row[D3M_INDEX_FIELD]
        );
      } else {
        removeRowSelection(
          this.$router,
          this.instanceName,
          this.rowSelection,
          row[D3M_INDEX_FIELD]
        );
      }
    },

    updateMarkerSelection(markers) {
      markers.forEach((marker) => {
        const row = marker.options.row;
        const markerElem = marker.getElement();
        const isSelected = isRowSelected(
          this.rowSelection,
          row[D3M_INDEX_FIELD]
        );
        markerElem.classList.toggle("selected", isSelected);
      });
    },

    showImageDrilldown(imageUrl: string, item: TableRow) {
      this.imageUrl = imageUrl ?? null;
      this.item = item ?? null;
      this.isImageDrilldown = true;
    },

    hideImageDrilldown() {
      this.isImageDrilldown = false;
    },

    colorPrediction(item: any) {
      let color = "#255DCC"; // Default

      if (item[this.targetField] && item[this.predictedField]) {
        color =
          item[this.targetField].value === item[this.predictedField].value
            ? "#03c003" // Correct: green.
            : "#be0000"; // Incorrect: red.
      }

      return color;
    },

    /* Create a Leaflet map, if it doesn't exist already, with basic defaults. */
    createMap() {
      if (this.map) {
        return;
      }

      // NOTE: this component re-mounts on any change, so do everything in here
      this.map = leaflet.map(this.mapID, {
        center: [30, 0],
        zoom: 2,
      });

      if (this.mapZoom) {
        this.map.setZoom(this.mapZoom, { animate: true });
      }

      if (this.mapCenter) {
        this.map.panTo(
          {
            lat: this.mapCenter[1],
            lng: this.mapCenter[0],
          },
          { animate: true }
        );
      }

      this.baseLayer.addTo(this.map);

      // this.map.on('click', this.clearSelection);
    },

    /* Create a Leaflet Group to contains the Point Of Interest (POI) if it doesn't exist already. */
    createPoiLayer(pois) {
      // Test if the area Layer is already on the map.
      if (this.map.hasLayer(this.poiLayer)) {
        // Let's clear all of it before adding new ones.
        this.poiLayer.clearLayers();
      } else {
        // Create a layer group to contain all the POIS to be displayed.
        this.poiLayer = leaflet.layerGroup();
        this.poiLayer.addTo(this.map);

        // Extend the bounds of the map to include all coordinates.
        const bounds = leaflet.latLngBounds(null);
        pois.forEach((poi) => {
          if (poi.coordinates) {
            poi.coordinates.forEach((coordinate) => bounds.extend(coordinate));
          } else {
            bounds.extend([poi.lat, poi.lng]);
          }
        });
        if (bounds.isValid()) {
          this.map.fitBounds(bounds);
        }
      }
    },

    /* Display areas as circleMarker or rectangle layers on the map. */
    displayAreas() {
      this.createPoiLayer(this.areas);

      // Add each area to the layer group.
      this.areas.forEach((area) => {
        const { color, coordinates, imageUrl, item } = area;

        // Create the layer (circleMarker or rectangle) for the user to interact.
        let layer: any;
        if (this.displayCircleMarker) {
          const centerOfCoordinates = [
            coordinates[0][0] + (coordinates[1][0] - coordinates[0][0]), // Lat
            coordinates[0][1] + (coordinates[1][1] - coordinates[0][1]), // Lng
          ] as LatLngTuple;
          const displayOptions = {
            color: color,
            radius: TARGETSIZE / 2,
            stroke: false,
            fillOpacity: 1.0,
          };
          layer = leaflet.circleMarker(centerOfCoordinates, displayOptions);
        } else {
          layer = leaflet.rectangle(coordinates, { color });
        }

        // Create a Vue tooltip for the area with the label for the image.
        const ImageLabelComponent = Vue.extend(ImageLabel);
        const tooltip = new ImageLabelComponent({
          parent: this,
          propsData: {
            dataFields: this.dataFields,
            includeActive: true,
            item: item,
          },
          store: this.$store,
        }).$mount();

        // Add interactivity to the layer.
        layer.bindTooltip(tooltip.$el as HTMLElement);
        if (this.isRemoteSensing) {
          layer.on("click", () => {
            this.showImageDrilldown(imageUrl, item);
          });
        }

        // Add the rectangle to the layer group.
        this.poiLayer.addLayer(layer);
      });
    },

    /* Display point as circleMarker on the map. */
    displayPoints() {
      this.createPoiLayer(this.pointGroups?.[0].points);

      this.pointGroups.forEach((group) => {
        const hash = this.fieldHash(group.field);
        const layerGroup = leaflet.layerGroup([]);

        group.points.forEach((point) => {
          const coordinate = [point.lat, point.lng] as LatLngTuple;
          const displayOptions = {
            className: "markerPoint",
            fillColor: point.color,
            fillOpacity: 1.0,
            radius: TARGETSIZE / 2,
            row: (<any>point).row,
            stroke: false,
          } as CircleMarkerOptions;
          const layer = leaflet.circleMarker(coordinate, displayOptions);

          layer.bindTooltip(() => {
            const target = point.row[this.target].value;
            const values = [];
            const MAX_VALUES = 5;

            this.getTopVariables.forEach((v) => {
              if (point.row[v] && values.length <= MAX_VALUES) {
                values.push(`<b>${_.capitalize(v)}:</b> ${point.row[v].value}`);
              }
            });

            return [`<b>${_.capitalize(target)}</b>`]
              .concat(values)
              .join("<br>");
          });

          layer.on("click", this.toggleSelection);

          // Add the point to the layer group.
          layerGroup.addLayer(layer);
        });

        this.markers[hash] = layerGroup;
        layerGroup.on("add", () =>
          this.updateMarkerSelection(layerGroup.getLayers())
        );

        // Add the point to the layer group.
        this.poiLayer.addLayer(layerGroup);
      });
    },

    paint() {
      this.createMap();

      if (this.isGeoSpatial) {
        // Display areas and update them on zoom to be sure they are selectable.
        this.displayAreas();
        this.map.on("zoomend", () => this.displayAreas());
      } else {
        this.displayPoints();
      }

      this.drawHighlight();
      this.drawFilters();
    },
    onNewData() {
      // clear polygons
      this.overlay.clearQuads();
      // create quads from latlng
      const quads = this.currentState.quads();
      // get bounds of quad set
      const mapBounds = this.getBounds(quads);
      // add the batched quads to a single layer on the overlay
      this.overlay.addQuad(this.polygonLayerId, quads);
      // fit map to the quad set
      this.map.fitToBounds(mapBounds);
    },
  },

  watch: {
    dataItems() {
      this.onNewData();
    },
    summaries(cur, prev) {
      if (!prev.length) {
        // if prev undefined update state and add zoom
        this.map.on(lumo.ZOOM_END, this.onZoom);
        if (this.map.getZoom() < this.zoomThreshold) {
          this.currentState = this.clusterState;
          this.updateMap();
        }
      }
    },

    rowSelection() {
      const markers = _.map(this.markers, (markerLayer) =>
        markerLayer.getLayers()
      ).reduce((prev, cur) => [...prev, ...cur], []);
      this.updateMarkerSelection(markers);
    },
  },

  mounted() {
    this.createLumoMap();
  },
});
</script>

<style>
.geo-plot-container,
.geo-plot {
  position: relative;
  z-index: 0;
  width: 100%;
  height: 100%;
  bottom: 0;
}

.geo-plot-container .selection-toggle {
  position: absolute;
  z-index: 999;
  top: 80px;
  left: 10px;
  width: 34px;
  height: 34px;
  background-color: #fff;
  border: 2px solid rgba(0, 0, 0, 0.2);
  background-clip: padding-box;
  text-align: center;
  border-radius: 4px;
}

.geo-plot-container .selection-toggle:hover {
  background-color: #f4f4f4;
}

.geo-plot-container .selection-toggle-control {
  text-decoration: none;
  color: black;
  cursor: pointer;
}

.geo-plot-container .selection-toggle-control:hover {
  text-decoration: none;
  color: black;
}

.geo-plot-container .selection-toggle.active {
  position: absolute;
}

.geo-plot-container .selection-toggle.active .selection-toggle-control {
  color: #26b8d1;
}

.geo-plot-container.selection-mode .geo-plot {
  cursor: crosshair;
}

path.selected {
  stroke-width: 2;
  fill-opacity: 0.4;
}

.geo-plot .markerPoint:hover {
  filter: brightness(1.2);
}

.geo-plot .markerPoint.selected {
  filter: hue-rotate(150deg);
}

.leaflet-tooltip {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 300px !important;
}

.geo-close-button {
  position: absolute;
  width: 24px;
  height: 24px;
  text-align: center;
  line-height: 24px;

  left: 8px;
  top: -24px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background-color: #fff;
  color: #000;
  cursor: pointer;
}

.geo-close-button:hover {
  background-color: #f4f4f4;
}
.geo-toast {
  position: absolute;
  top: 0px;
  right: 0px;
}
.image-label {
  position: absolute;
  left: 2px;
  top: 2px;
  z-index: 1;
}
</style>
